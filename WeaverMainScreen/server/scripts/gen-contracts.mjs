// Tiny typegen for OpenAPI -> TS types using CLI to ensure TS string output
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import fs from 'fs/promises';
import { execFile } from 'child_process';
import { promisify } from 'util';
const execFileAsync = promisify(execFile);

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const specPath = resolve(__dirname, '../contracts/openapi.yaml');
const outDir = resolve(__dirname, '../../shared/generated');
const outPath = resolve(outDir, 'api.ts');
await fs.mkdir(outDir, { recursive: true });

let success = false; let lastErr = null;
async function tryNpx() {
	const bin = process.platform === 'win32' ? 'npx.cmd' : 'npx';
	return execFileAsync(bin, ['--yes', 'openapi-typescript', specPath, '-o', outPath], { cwd: resolve(__dirname, '..') });
}
async function tryLocalBin() {
	const binDir = resolve(__dirname, '../node_modules/.bin');
	let cliPath = resolve(binDir, 'openapi-typescript');
	if (process.platform === 'win32') cliPath += '.cmd';
	return execFileAsync(cliPath, [specPath, '-o', outPath], { cwd: resolve(__dirname, '..') });
}
async function tryProgrammatic() {
	const mod = await import('openapi-typescript').catch(() => null);
	if (!mod?.default) throw new Error('openapi-typescript module not found');
	const spec = await fs.readFile(specPath, 'utf8');
	const ts = await mod.default(spec, { });
	await fs.writeFile(outPath, `// AUTO-GENERATED by gen-contracts.mjs. Do not edit by hand.\n` + ts, 'utf8');
}

for (const attempt of [tryNpx, tryLocalBin, tryProgrammatic]) {
	if (success) break;
	try {
		const r = await attempt();
		if (r?.stderr && r.stderr.trim()) console.warn('[typegen]', r.stderr.trim());
		if (r?.stdout && r.stdout.trim()) console.log('[typegen]', r.stdout.trim());
		// If CLI wrote the file, add banner
		if (await fileExists(outPath)) {
			const orig = await fs.readFile(outPath, 'utf8');
			if (!orig.startsWith('// AUTO-GENERATED')) {
				await fs.writeFile(outPath, `// AUTO-GENERATED by gen-contracts.mjs. Do not edit by hand.\n` + orig, 'utf8');
			}
		}
		success = true;
	} catch (e) {
		lastErr = e;
	}
}

if (!success) {
	// If we already have a file, keep going; otherwise write a tiny placeholder
	if (await fileExists(outPath)) {
		console.warn('[typegen] Failed to regenerate types, using existing file. Last error:', lastErr?.message || String(lastErr));
	} else {
		const placeholder = `// AUTO-GENERATED placeholder. Replace by running gen-contracts.mjs\nexport type paths = {};\nexport type components = { schemas: {} };\n`;
		await fs.writeFile(outPath, placeholder, 'utf8');
		console.warn('[typegen] Wrote placeholder types due to generation failure.');
	}
}
console.log(`[typegen] Wrote ${outPath}`);

async function fileExists(p) {
	try { const s = await fs.stat(p); return s.isFile(); } catch { return false; }
}
